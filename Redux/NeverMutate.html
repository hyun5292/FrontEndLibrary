<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/redux/5.0.0-alpha.0/redux.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/redux-thunk/2.2.0/redux-thunk.min.js"></script>
    <title>Never Mutate State</title>
</head>
<body>
    <script type="text/babel">
        const ADD_TO_DO = 'ADD_TO_DO';

        const todos = [
            'Go to the store',
            'Clean the house',
            'Cook dinner',
            'Learn to code',
        ];

        const immutableReducer = (state = todos, action) => {
            switch(action.type) {
                case ADD_TO_DO: 
                    return state.concat(action.todo);
                default: 
                    return state;
            };
        };

        const addToDo = (todo) => {
            return {
                type: ADD_TO_DO,
                todo
            }
        };

        const store = Redux.createStore(immutableReducer);
    </script>
</body>
</html>
<!--
////Never Mutate State
These final challenges describe several methods of enforcing the key principle of state
immutability in Redux. Immutable state means that you never modify state directly, instead,
you return a new copy of state.

If you took a snapshot of the state of a Redux app over time, you would see something like 
state 1, state 2, state 3, state, 4, ... and so on where each state may be similar to the
last, but each is a distinct piece of data. This immutability, in fact, is what provides
such features as time-travel debugging that you may have heard about.

Redux does not actively enforce state immutability in its store or reducers, that responsiblity
falls on the programmer. Fortunately, JavaScript (especially ES6) provides several useful tools
you can use to enforce the immutability of your state, whether it is a string, number, array
or object. Note that strings and numbers are primitive values and are immutable by nature. In
other words, 3 is always 3. You cannot change the value of the number 3. An array or object,
however, is mutable. In practice, your state will probably consist of an array or object, as
these are useful data structures for represengting many types of information.
----------------------------------------------------------------------------------------------
There is a store and reducer in the code editor for managing to-do items. Finish writing the
ADD_TO_DO case in the reducer to append a new to-do to the state. There are a few ways to 
accomplish this with standard JavaScript or ES6. See if you can find a way to return a new
array with the item from action.todo appended to the end.
-->